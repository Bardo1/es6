<!DOCTYPE html>
<html lang="es-AR">
<head>
  <meta charset="UTF-8" />
  <title>ECMAScript 6: el futuro de JavaScript</title>
  <!-- dns prefetch -->
  <link rel="dns-prefetch" href="//www.google-analytics.com" />
  <link rel="dns-prefetch" href="//cdnjs.cloudflare.com" />
  <!-- normalize -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css" />
  <!-- github fork ribbon -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.1.1/gh-fork-ribbon.min.css" />
  <!--[if lt IE 9]>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.1.1/gh-fork-ribbon.ie.min.css" />
  <![endif]-->
  <!-- own styles -->
  <link rel="stylesheet" href="assets/css/style.min.css" />
  <!-- prefix-free -->
  <script src="//cdnjs.cloudflare.com/ajax/libs/prefixfree/1.0.7/prefixfree.min.js"></script>
  <!-- viewport -->
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" />
  <!-- import ribbon -->
  <link rel="import" href="gh-fork-ribbon.html" />
</head>
<body>
  <header>
    <h1>ECMAScript 6: el futuro de JavaScript</h1>
    <a href="//twitter.com/sergiodxa" target="_blank" rel="author">@sergiodxa</a>
  </header>

  <main class="presentacion language-bash">
    <section>
      <h2>¿Qué es ECMAScript 6?</h2>
      <article>
        <p>
          ECMAScript 6 es la nueva versión del lenguaje estandar ECMAScript que va a estar terminada en Junio de este año (2015). ES6 es la primer actualización al lenguaje desde que en 2008 salio ECMAScript 5.
        </p>
      </article>
    </section>

    <section>
      <h2>Usando ECMAScript 6 hoy</h2>
      <article>
        <h3>Babel.js</h3>
        <figure>
          <img src="//babeljs.io/images/logo.svg" alt="Babel.js logo" style="max-width:550px;width:100%;"  target="_blank"/>
        </figure>
        <p>
          <a href="//babeljs.io/" target="_blank">Babel.js</a> es un transpiler que permite convertír código de ECMAScript 6 a código legible de ECMAScript 5 compatible con la mayoría de navegadores modernos.
        </p>
      </article>

      <article>
        <h3>Instalando Babel.js</h3>
        <p>
          Para poder usarlo lo primero es instalarlo, para esto necesitamos tener <a href="//nodejs.org/" target="_blank">Node.js</a> o <a href="//iojs.org/" target="_blank">io.js</a> instalado en nuestra computadora.
        </p>
        <p>Una vez instalado <strong>node</strong> (desde acá voy a usar node para referirme a io.js y Node.js) usando <abbr title="Ninja Pokémon Master">NPM</abbr> instalamos Babel.js de forma global con el comando</p>
        <pre><code>sudo npm i -g babel</code></pre>
        <p>
          Luego cuando queramos usar Babel podemos usamos el siguiente comando.
        </p>
        <pre><code>babel archivo.js</code></pre>
        <p>
          Este nos va a convertir el código de archivo.js de ES6 a ES5 y mostrar el resultado en la consola.
        </p>
        <pre><code>babel-node archivo.js</code></pre>
        <p>
          Este nos va a convertir el código de archivo.js y ejecutarlo con node, de esta forma podemos usar todas las características de ES6 en node.
        </p>
      </article>

      <article>
        <h3>Usando Babel con Browserify</h3>
        <p>
          Babel se puede utilizar con <a href="//www.npmjs.com/package/browserify" target="_blank">Browserify</a> gracias a un plugin de este llamado <a href="//www.npmjs.com/package/babelify" target="_blank">Babelify</a>, para esto simplemente instalan Browserify y Babel como dependencia de desarrollo de su proyecto con el siguiente comando.
        </p>
        <pre><code>[sudo] npm i -D browserify babelify</code></pre>
        <p>
          Luego utilizamos Browserify pasandole Babelify como transform con el comando:
        </p>
        <pre><code>browserify -t babelify -i src/main.jsx -o build/main.js</code></pre>
        <p>
          Esto va a convertír nuestro código ES6 a ES5, generar un único archivo a partír de nuestro main.js ubicado en la carpeta <em>src</em>, cargar los módulos que hayamos requerido desde <em>node_modules</em> y crear un único archivo ES5 en la carpeta <em>build</em>.
        </p>
      </article>

      <article>
        <h3>Usando Babel con Gulp</h3>
        <p>
          Babel también se puede utilizar con <a href="//gulpjs.com/" target="_blank">Gulp.js</a> utilizando el plugin <a href="//www.npmjs.com/package/gulp-babel" target="_blank">gulp-babel</a>, para esto descargan Gulp.js y gulp-babel con el siguiente comando.
        </p>
        <pre><code>[sudo] npm i -D gulp gulp-babel</code></pre>
        <p>
          Luego creamos una tarea de Gulp en nuestro archivo gulpfile.js en la raíz del proyecto en la cual leemos los archivos en ES6, ejecutamos gulp-babel y luego guardamos los archivos generados en otra carpeta.
        </p>
        <pre class="language-javascript"><code>var gulp  = require('gulp');
var babel = require('gulp-babel');

gulp.task('js', function () {
  gulp.src('/src/es6/*.js')
    .pipe(babel())
    .pipe(gulp.dest('/build/js/'));
});</code></pre>
      </article>
    </section>

    <section>
      <h2>Variables de bloque y constantes</h2>
      <article>
        <h3>Variables de bloque</h3>
        <p>
          En ES6 se agrega una nueva forma de definir variables usando la palabra <strong>let</strong> en vez de <strong>var</strong>.
        </p>
        <p>
          Se diferencia de <strong>var</strong> en que el scope de una variable definida con <strong>let</strong> es el bloque en el cual se encuentra la variable y no la función.
        </p>
        <h4>Ejemplo:</h4>
        <pre data-src="examples/es6/block-scope-variables.js"></pre>
        <button type="button" data-src="examples/es5/block-scope-variables.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Constantes</h3>
        <p>
          Algo que sin duda faltaba en JS era las constantes. Con ES6 es posible definir tus propias constantes usando la palabra <strong>const</strong> en lugar de <strong>let</strong> o <strong>var</strong>.
        </p>
        <p>
          Una constantes como el nombre indica no puede cambiar de valor una vez definida, tiene un valor constante.
        </p>
        <p>
          Las constantes también tienen un scope de bloque.
        </p>
        <pre data-src="examples/es6/constants.js"></pre>
        <button type="button" data-src="examples/es6/constants.js">Ejecutar</button>
      </article>
    </section>

    <section>
      <h2>Template strings</h2>
      <article>
        <p>
          Los template string son una forma más fácil de crear strings con variables en medio del string o strings multilínea.
        </p>
      </article>

      <article>
        <h3>Variables en strings</h3>
        <p>
          Para meter una variable dentro de un template string hay que colocar el nombre de esta variable entre de <strong>${</strong> y <strong>}</strong> (no solo variables, incluso pueden ejecutar funciones o colocar expresiones como 2+2).
        </p>
        <pre data-src="examples/es6/template-strings-variables.js"></pre>
        <button type="button" data-src="examples/es5/template-strings-variables.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Strings multilínea</h3>
        <p>
          Para poder crear un string multilínea con template strings basta con apretar enter y en la siguiente línea seguír escribiendo.
        </p>
        <pre data-src="examples/es6/template-strings-multiline.js"></pre>
        <button type="button" data-src="examples/es5/template-strings-multiline.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Números en Octal y Binario</h2>
      <article>
        <h3>Números en Octal</h3>
        <p>
          Desde ES6 va a ser posible definir variables usando números en Octal con el siguiente código
        </p>
        <pre data-src="examples/es6/octal.js"></pre>
        <button type="button" data-src="examples/es6/octal.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Números en Binario</h3>
        <p>
          Desde ES6 va a ser posible definir variables usando números en Binario con el siguiente código
        </p>
        <pre data-src="examples/es6/binario.js"></pre>
        <button type="button" data-src="examples/es6/binario.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Objeto Math</h2>
      <article>
        <p>
          En ES6 se agregan una lista de nuevos métodos al objeto Math, casi todos ya están soportados desde hace un par de años en los navegadores.
        </p>
        <ul>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh" target="_blank">
              .acosh()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asin" target="_blank">
              .asinh()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh" target="_blank">
              .atanh()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt" target="_blank">
              .cbrt()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32" target="_blank">
              .clz32()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh" target="_blank">
              .cosh()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1" target="_blank">
              .exp1m()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround" target="_blank">
              .fround()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot" target="_blank">
              .hypot()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul" target="_blank">
              .imul()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10" target="_blank">
              .log10()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p" target="_blank">
              .log1p()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2" target="_blank">
              .log2()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign" target="_blank">
              .sign()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh" target="_blank">
              .sinh()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh" target="_blank">
              .tanh()
            </a>
          </li>
          <li>
            <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc" target="_blank">
              .trunc()
            </a>
          </li>
        </ul>
        <p>
          No puse ejemplos porque son muchos y se pueden ver en <a href="//developer.mozilla.org/en-US/">Mozilla Developer Network</a>.
        </p>
      </article>
    </section>

    <section>
      <h2>Métodos de Arrays</h2>
      <article>
        <h3>Array.from(array, mapFn)</h3>
        <p>
          Este nuevo método del objeto Array permite crear un array copiando otro array o un NodeList.
        </p>
        <p>
          Es posible utilizarlos actualmente mediantes <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#Polyfill" target="_blank">polyfills</a>.
        </p>
        <pre data-src="examples/es6/array.from.js"></pre>
        <button type="button" data-src="examples/es5/array.from.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Otros métodos</h3>
        <p>
          Además de .from() se agregaron los siguientes métodos:
        </p>
        <ul>
          <li><a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of">.of()</a>: crea un nuevo array con un número variado de elementos</li>
          <li><a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">.fill()</a>: llena un array con un nuevo valor en cada elemento</li>
          <li><a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find">.find()</a>: busca un elemento dentro de un array y devuelve el valor</li>
          <li><a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">.findIndex()</a>: similar a .find() pero devuelve el índice</li>
          <li><a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries">.entries()</a>: devuelve una instancia del objeto Iterator que contiene cada índice y valor del array</li>
          <li><a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys">.keys()</a>: similar a .entries() pero el Iterator solo muestra los índices</li>
          <li><a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin">.copyWithin()</a>: copia los elementos de un array en las posiciones indicadas</li>
        </ul>
      </article>
    </section>

    <section>
      <h2>Métodos de Object</h2>
      <article>
        <h3>Object.assign(objetivo, ...objs)</h3>
        <p>
          Este nuevo método permite asignar propiedades de uno o más objetos a otro objeto pisando las propiedades con nombres repetidos por el valor del último objeto indicado.
        </p>
        <p>
          Esta propiedad es muy útil para realizar herencia entre objetos.
        </p>
        <p>
          Este método se puede utilizar ya gracias a un <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank">polyfill</a>
        </p>
        <pre data-src="examples/es6/object.assign.js"></pre>
        <button type="button" data-src="examples/es5/object.assign.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Object.is(valor1, valor2)</h3>
        <p>
          Este nuevo método sirve para comparar si dos valores son iguales, devuelve true si ambos son:
        </p>
        <ul>
          <li>undefined</li>
          <li>null</li>
          <li>true o false</li>
          <li>strings con el mismo largo y los mismos caracteres</li>
          <li>el mismo objeto</li>
          <li>
            números y ambos:
            <ul>
              <li>son mayores a 0</li>
              <li>son menores a 0</li>
              <li>son NaN</li>
              <li>no son 0, no son NaN y son el mismo número</li>
            </ul>
          </li>
        </ul>
        <p>
          Al igual que .assign() se puede utilizar ya mismo mediante un <a href="//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank">polyfill</a>.
        </p>
        <pre data-src="examples/es6/object.is.js"></pre>
        <button type="button" data-src="examples/es5/object.is.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Forma abreviada de definición de Objetos</h2>
      <article>
        <h3>Asignación de propiedades</h3>
        <p>
          Con ES6 ahora va a ser mucho más simple (y lógico) utilizar una variable para definir el valor de una propiedad de un objeto.
        </p>
        <pre data-src="examples/es6/shorthand-object-definition-props.js"></pre>
        <button type="button" data-src="examples/es5/shorthand-object-definition-props.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Asignación de métodos</h3>
        <p>
          Al igual que es más fácil usar variables en propiedades también se simplificó la forma de definir métodos en un objeto.
        </p>
        <pre data-src="examples/es6/shorthand-object-definition-methods.js"></pre>
        <button type="button" data-src="examples/es5/shorthand-object-definition-methods.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Asignación por descomposición</h2>
      <article>
        <p>
          Si ya dijimos que con ES6 nos es más fácil crear objetos usando variables, también nos vas a ser más fácil hacer lo contrarios, descomponer un objeto (o un array) en variables
        </p>
        <pre data-src="examples/es6/destructuring.js"></pre>
        <button type="button" data-src="examples/es5/destructuring.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Parámetros por defecto</h2>
      <article>
        <p>
          Algo que siempre falto en JS al momento de definir funciones eran los parámetros con valores por defecto, siendo la única forma de lograr esto redefinir el valor de un parámetro con el mismo parámetro o el valor por defecto (no muy optimo que digamos).
        </p>
        <p>
          Con ES6 ahora es completamente posible definir un valor por defecto a los parámetros de nuestras funciones al igual que en otros lenguajes de programación.
        </p>
        <pre data-src="examples/es6/default-params.js"></pre>
        <button type="button" data-src="examples/es5/default-params.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Arrow functions</h2>
      <article>
        <p>
          Arrow function es una nueva forma de definir funciones en JS similar a como hace CoffeeScript.
        </p>
        <p>
          Hay distintas variantes en la sintaxis de las arrow function.
        </p>
      </article>

      <article>
        <h3>Función de un solo parámetro</h3>
        <p>
          Al crear una arrow function de un solo parámetro no es necesario escribír los paréntesis.
        </p>
        <p>
          Como se puede ver en el ejemplo tampoco es necesario escribír las llaves siempre. Esto ocurre solo cuando la función es de una sola línea y devuelve un valor.
        </p>
        <pre data-src="examples/es6/arrow-func-single-param.js"></pre>
        <button type="button" data-src="examples/es5/arrow-func-single-param.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Función de varios parámetros</h3>
        <p>
          En el caso de que queramos utilizar más de un parámetro ahí sí es necesario envolver el nombre de estos entre paréntesis.
        </p>
        <pre data-src="examples/es6/arrow-func-multi-params.js"></pre>
        <button type="button" data-src="examples/es5/arrow-func-multi-params.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Función sin parámetros</h3>
        <p>
          También son necesarios los paréntesis si queremos crear una función que no reciba parámetros.
        </p>
        <pre data-src="examples/es6/arrow-func-no-params.js"></pre>
        <button type="button" data-src="examples/es5/arrow-func-no-params.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Función con cuerpo</h3>
        <p>
          Por último, si la función tiene más de una línea (o no devuelve ningún valor) es necesario utilizar las llaves.
        </p>
        <pre data-src="examples/es6/arrow-func-with-body.js"></pre>
        <button type="button" data-src="examples/es5/arrow-func-with-body.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Parámetros rest</h2>
      <article>
        <p>
          Los parámetros rest son una forma de utilizar parámetros virtualmente infinitos (nunca supe de ningún límite) en una función que vendría a substituír al array arguments que tienen actualmente las funciones.
        </p>
        <p>
          Los parámetros rest se definen agregando <strong>...</strong> adelante del nombre que se le quiera asignar al mismo. El parámetro rest tiene que ser siempre el último parámetro de una función.
        </p>
        <pre data-src="examples/es6/rest-params.js"></pre>
        <button type="button" data-src="examples/es5/rest-params.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Promesas</h2>
      <article>
        <p>
          Las promesas es algo que se viene usando ya desde hace un par de años gracias a librerías como <a href="//documentup.com/kriskowal/q/" target="_blank">Q</a>.
        </p>
        <p>
          En ES6 las promesas van a pasar a tener soporte nativo del lenguaje con una sintaxis bastante simple.
        </p>
        <pre data-src="examples/es6/promises.js"></pre>
        <button type="button" data-src="examples/es5/promises.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Generadores</h2>
      <article>
        <p>
          Los generadores son un tipo de función especial que permite parar la ejecución de la misma y devolver un valor, para luego poder seguír ejecutándola.
        </p>
        <pre data-src="examples/es6/generators.js"></pre>
        <a href="//babeljs.io/repl/#?experimental=true&evaluate=true&loose=true&spec=false&playground=false&code=function*%20fibonacci()%20%7B%0A%20%20let%20anterior%20%3D%200%2C%20actual%20%3D%201%3B%0A%20%20while(true)%20%7B%0A%20%20%20%20let%20temp%20%3D%20anterior%3B%0A%20%20%20%20anterior%20%3D%20actual%3B%0A%20%20%20%20actual%20%2B%3D%20temp%3B%0A%20%20%20%20yield%20actual%3B%0A%20%20%7D%0A%7D%0A%0Alet%20fibo%20%3D%20fibonacci()%3B%0A%0Afor%20(let%20i%20%3D%200%3B%20i%20%3C%205%3B%20i%2B%2B)%20%7B%0A%20%20console.log(fibo.next())%3B%20%2F%2F%20%7B%20value%3A%20n%2C%20done%3A%20false%20%7D%0A%7D" target="_blank" class="button">
          Ejecutar
        </a>
      </article>
    </section>

    <section>
      <h2>Iterators y for...of</h2>
      <article>
        <h3>Iterators</h3>
        <p>
          Los Iterators son un tipo de objeto que nos permite iterarlos usando el método .next() (los generadores son instancias de Iterator).
        </p>
        <pre data-src="examples/es6/iterator.js"></pre>
        <button type="button" data-src="examples/es5/iterator.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>for...of</h3>
        <p>
          Este es un nuevo bucle similar a for...in donde la variable que usamos para recorrer un array devuelve el valor de cada elemento y no la posición.
        </p>
        <p>
          Este bucle sirve perfectamente para recorrer un Iterator.
        </p>
        <pre data-src="examples/es6/for-of.js"></pre>
        <button type="button" data-src="examples/es5/for-of.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Proxies</h2>
      <article>
        <p>
          Los proxies de ES6 te permiten interceptar y personalizar las distintas operaciones que se pueden realizar en un objeto.
        </p>
        <pre data-src="examples/es6/proxies.js"></pre>
      </article>
    </section>

    <section>
      <h2>Clases</h2>
      <article>
        <p>
          Desde ES6 se incorporan al lenguaje clases para poder hacer POO más facilmente (sin prototype). Las clases de ES6 son solo un syntax sugar de la como se hace actualmente con prototype.
        </p>
      </article>

      <article>
        <h3>Definición de clase</h3>
        <p>
          Para definir una clase simplemente se usa la palabra <strong>class</strong> seguida del nombre de la clase y luego entre llaves los métodos de esta.
        </p>
        <pre data-src="examples/es6/class.js"></pre>
        <button type="button" data-src="examples/es5/class.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Extendiendo una clase</h3>
        <p>
          Al igual que en otros lenguajes es posible extender una clase agregando <strong>extends ClaseBase</strong> luego del nombre de la nueva clase.
        </p>
        <pre data-src="examples/es6/class-extends.js"></pre>
        <button type="button" data-src="examples/es5/class-extends.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Métodos estáticos</h3>
        <p>
          También es posible definir métodos estáticos que se pueden ejecutar sin necesidad de instanciar la clase simplemente agregando <strong>static</strong> antes del nombre del método (el método constructor no puede ser estático).
        </p>
        <pre data-src="examples/es6/class-static.js"></pre>
        <button type="button" data-src="examples/es5/class-static.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Getters y Setters</h3>
        <p>
          Por último también es posible definir getter y setters agregando <strong>get</strong> o <strong>set</strong> antes del nombre de un método.
        </p>
        <pre data-src="examples/es6/class-getter-setter.js"></pre>
        <button type="button" data-src="examples/es5/class-getter-setter.js">
          Ejecutar
        </button>
      </article>
    </section>

    <section>
      <h2>Módulos</h2>
      <article>
        <p>
          Desde ES6 vamos a tener un sistema nativo de módulos que viene a sustituir a los actuales CommonJS, AMD, etc.
        </p>
        <p>
          Hay varias formas de exportar e importar módulos con el nuevo sistema.
        </p>
      </article>

      <article>
        <h3>Exportación única</h3>
        <p>
          La primera forma es cuando tenemos un solo dato a exportar (una función, un objeto, etc.), para esto usamos la siguiente sintaxis.
        </p>
        <pre data-src="examples/es6/module-export-default.js"></pre>
      </article>

      <article>
        <h3>Multiples exportaciones</h3>
        <p>
          Se puede dar el caso de querer exportar muchos datos al mismo tiempo, para eso simplemente quitamos el default luego del export.
        </p>
        <pre data-src="examples/es6/module-export.js"></pre>
      </article>

      <article>
        <h3>Combinandolos</h3>
        <p>
          Por último puede pasar que quieras dejar una exportación por defecto y la posibilidad de importar otros datos especificando.
        </p>
        <pre data-src="examples/es6/module-export-multiple.js"></pre>
      </article>

      <article>
        <h3>Importando de forma síncrona</h3>
        <p>
          Para importar hay dos forma, la primera es la forma síncrona, esta a su vez tiene varias forma. pero todas se basan es usa <strong>import</strong> seguido del nombre que se le quiere dar al módulo a importar y luego <strong>from</strong> y la ubicación del módulo en un string.
        </p>
        <pre data-src="examples/es6/module-import-sync.js"></pre>
      </article>

      <article>
        <h3>Importando de forma asíncrona</h3>
        <p>
          La otra forma es la importación asíncrona de módulos, esta además tiene la característica de que va a funcionar desde etiquetas <em>&lt;script&gt;</em> en el HTML.
        </p>
        <p>
          La forma asíncrona tiene dos variantes, una que es la más simple, para cargar un solo módulo, la otra que requiere el uso de promesas permite cargar múltiples módulos de forma asíncrona.
        </p>
        <pre data-src="examples/es6/module-import-async.js"></pre>
      </article>
    </section>

    <section>
      <h2>Symbols</h2>
      <article>
        <h3>Creando y usando un Symbol</h3>
        <p>
          Los Symbol son un nuevo tipo de <a href="//javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/" target="_blank">primitivo</a> inmutable pensado para ser usado principalmente como identificado de las propiedades de un objeto.
        </p>
        <p>
          Con la incorporación de los Symbol las propiedades de un objeto ahora se podrán acceder tanto con comillas como sin comillas.
        </p>
        <pre data-src="examples/es6/symbol.js"></pre>
        <button type="button" data-src="examples/es5/symbol.js">
          Ejecutar
        </button>
      </article>

      <article>
        <h3>Symbol.for()</h3>
        <p>
          El objeto Symbol (usado para crear un nuevo primitivo Symbol) posee un método llamado .for(). Este método tiene dos usos, el primero es la creación de un nuevo Symbol, sin necesidad de asignar a una variable, el segundo es encontrar un Symbol ya creado.
        </p>
        <pre data-src="examples/es6/symbol.for.js"></pre>
        <button type="button" data-src="examples/es5/symbol.for.js">
          Ejecutar
        </button>
      </article>
    </section>
  </main>

  <!-- prism library -->
  <script src="//cdnjs.cloudflare.com/ajax/libs/prism/0.0.1/prism.min.js"></script>
  <!-- jquery -->
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <!-- own js -->
  <script src="assets/js/main.min.js"></script>
</body>
</html>